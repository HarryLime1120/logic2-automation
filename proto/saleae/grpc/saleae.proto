syntax = "proto3";

option java_multiple_files = true;
option java_package = "saleae";
option java_outer_classname = "SaleaeProto";
option objc_class_prefix = "Saleae";

package saleae.automation;


service Manager {
  rpc GetDevices (GetDevicesRequest) returns (GetDevicesReply) {}

  rpc StartCapture (StartCaptureRequest) returns (StartCaptureReply) {}
  rpc StopCapture (StopCaptureRequest) returns (StopCaptureReply) {}

  rpc LoadCapture (LoadCaptureRequest) returns (LoadCaptureReply) {}
  rpc SaveCapture (SaveCaptureRequest) returns (SaveCaptureReply) {}
  rpc CloseCapture (CloseCaptureRequest) returns (CloseCaptureReply) {}

  rpc ExportRawDataCsv (ExportRawDataCsvRequest) returns (ExportRawDataCsvReply) {}
  rpc ExportRawDataBinary (ExportRawDataBinaryRequest) returns (ExportRawDataBinaryReply) {}
}


// Core Types

enum ErrorCode {
    UNKNOWN = 0; // Not used

    INTERNAL_EXCEPTION = 1;

    INVALID_REQUEST = 10;

    LOAD_CAPTURE_FAILED = 20;

    CAPTURE_IN_PROGRESS = 21;
    UNSUPPORTED_FILE_TYPE = 22;

    MISSING_DEVICE = 50;
    DEVICE_ERROR = 51;
    OOM = 52;
}

// Enum fields don't explicitly track presence if not tagged as optional. In these cases
// 0 is the implicitly serialized value, which is indistinguishable from the 0 value in the enum.
// But 0 is required as the first value in an enum. This should be set to something like UNKNOWN instead.
// Or we should always mark them as optional? I'm not sure how the client-side handles that if the value is 
// present but 0.
enum DeviceType {
    UNKNOWN_DEVICE_TYPE = 0;
    LOGIC_8 = 1;
    LOGIC_PRO_8 = 2;
    LOGIC_PRO_16 = 3;
}

message Device {
    uint64 device_id = 1;
    DeviceType device_type = 2;
    string serial_number = 3;
}

enum ChannelType {
    DIGITAL = 0;
    ANALOG = 1;
}

message ChannelIdentifier {
    uint64 device_id = 1;
    ChannelType type = 2;
    uint64 index = 3;
}

message CaptureInfo {
    uint64 capture_id = 1;
}



// Request/Reply Types


// Get Devices
message GetDevicesRequest {
}
message GetDevicesReply {
    repeated Device devices = 1;
}


// Start Capture
message StartCaptureRequest {
    string device_serial_number = 1;

    oneof device_configuration {
        LogicDeviceConfiguration logic_device_configuration = 2;
    }
}
message StartCaptureReply {
    CaptureInfo capture_info = 1;
}

message LogicDeviceConfiguration {
    repeated uint32 enabled_analog_channels = 1;
    repeated uint32 enabled_digital_channels = 2;

    uint32 digital_sample_rate = 3;
    uint32 analog_sample_rate = 4;

    double digital_threshold = 5;

    repeated GlitchFilterEntry glitch_filter = 6;
}
message GlitchFilterEntry {
    uint32 channel_index = 1;
    double pulse_width = 2;
}

// Stop Capture
message StopCaptureRequest {
    uint64 capture_id = 1;
}
message StopCaptureReply {
}


// Load Capture
message LoadCaptureRequest {
    string filepath = 1;
}
message LoadCaptureReply {
    CaptureInfo capture_info = 1;
}

// Save Capture
message SaveCaptureRequest {
    uint64 capture_id = 1;
    string filepath = 2;
}
message SaveCaptureReply {
}


// Close Capture
message CloseCaptureRequest {
    uint64 capture_id = 1;
}
message CloseCaptureReply {
}


// Export Raw Data
message ExportRawDataCsvRequest {
    uint64 capture_id = 1;

    string directory = 2;

    repeated ChannelIdentifier channels = 3;

    // Must be between 1 and 1,000,000, inclusive
    uint64 analog_downsample_ratio = 4;

    // If set to true, timestamps will be in ISO8601 format
    bool iso8601 = 5;
}
message ExportRawDataCsvReply {
}

message ExportRawDataBinaryRequest {
    uint64 capture_id = 1;

    string directory = 2;

    repeated ChannelIdentifier channels = 3;

    // Must be between 1 and 1,000,000, inclusive
    uint64 analog_downsample_ratio = 4;
}
message ExportRawDataBinaryReply {
}