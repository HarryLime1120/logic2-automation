syntax = "proto3";

option java_multiple_files = true;
option java_package = "saleae";
option java_outer_classname = "SaleaeProto";
option objc_class_prefix = "Saleae";

package saleae.automation;


/*****************************************************************************
 *
 * gRPC API
 *
 ****************************************************************************/

service Manager {
    // Get list of connected devices.
    rpc GetDevices (GetDevicesRequest) returns (GetDevicesReply) {}
  
    // Start a capture
    rpc StartCapture (StartCaptureRequest) returns (StartCaptureReply) {}

    // Stop an active capture
    rpc StopCapture (StopCaptureRequest) returns (StopCaptureReply) {}

    // Wait until a capture has completed
    rpc WaitCapture (WaitCaptureRequest) returns (WaitCaptureReply) {}

    // Load a capture from file.
    rpc LoadCapture (LoadCaptureRequest) returns (LoadCaptureReply) {}

    // Save a capture to file.
    rpc SaveCapture (SaveCaptureRequest) returns (SaveCaptureReply) {}

    // Close a capture.
    // Note: It is recommended to close a capture once it is no longer being used so that any
    //       consumed resources can be released.
    rpc CloseCapture (CloseCaptureRequest) returns (CloseCaptureReply) {}
  
    // Add an analyzer to a capture.
    rpc AddAnalyzer (AddAnalyzerRequest) returns (AddAnalyzerReply) {}

    // Remove an analyzer from a capture.
    rpc RemoveAnalyzer (RemoveAnalyzerRequest) returns (RemoveAnalyzerReply) {}
  
    // Export raw channel data to CSV files.
    rpc ExportRawDataCsv (ExportRawDataCsvRequest) returns (ExportRawDataCsvReply) {}

    // Export raw channel data to binary files.
    rpc ExportRawDataBinary (ExportRawDataBinaryRequest) returns (ExportRawDataBinaryReply) {}
  
    // Export analyzer data to CSV file.
    rpc ExportDataTable (ExportDataTableRequest) returns (ExportDataTableReply) {}

    // Export custom analyzer export data to file.
    rpc ExportAnalyzerLegacy (ExportAnalyzerLegacyRequest) returns (ExportAnalyzerLegacyReply) {}
}



/*****************************************************************************
 *
 * Core Types
 *
 ****************************************************************************/

enum ErrorCode {
    UNKNOWN_ERROR_CODE = 0; // Not used

    // Unexpected Saleae Internal Error.
    INTERNAL_EXCEPTION = 1;

    // Request is invalid, usually because of invalid arguments.
    //
    // Examples:
    //   Invalid Capture Id - capture does not exist
    //   Missing filepath
    INVALID_REQUEST = 10;

    LOAD_CAPTURE_FAILED = 20;
    CAPTURE_IN_PROGRESS = 21;
    UNSUPPORTED_FILE_TYPE = 22;

    MISSING_DEVICE = 50;
    DEVICE_ERROR = 51;
    OOM = 52;
}

enum RadixType {
    UNKNOWN_RADIX_TYPE = 0;

    BINARY = 1;
    DECIMAL = 2;
    HEXADECIMAL = 3;
    ASCII = 4;
};

enum DeviceType {
    // Invalid Device Type
    UNKNOWN_DEVICE_TYPE = 0;

    // Saleae Logic 8
    LOGIC_8 = 1;

    // Saleae Logic Pro 8
    LOGIC_PRO_8 = 2;

    // Saleae Logic Pro 16
    LOGIC_PRO_16 = 3;
}

// Device descriptor object.
message Device {
    // The id used to identify this device
    uint64 device_id = 1;

    // The type of this device
    DeviceType device_type = 2;

    // The serial number of this device
    string serial_number = 3;
}

enum ChannelType {
    UNKNOWN_CHANNEL_TYPE = 0;

    // Digial channel.
    DIGITAL = 1;

    // Analog data.
    ANALOG = 2;
}

// Identification for a channel.
message ChannelIdentifier {
    // Device id
    uint64 device_id = 1;

    // Channel type.
    ChannelType type = 2;

    // Index of channel.
    uint64 index = 3;
}

message CaptureInfo {
    // Id of the capture.
    uint64 capture_id = 1;
}



/*****************************************************************************
 *
 * Request/Reply Messages
 *
 ****************************************************************************/

message GetDevicesRequest {
}
message GetDevicesReply {
    repeated Device devices = 1;
}


// Start Capture
message StartCaptureRequest {
    string device_serial_number = 1;

    oneof device_configuration {
        LogicDeviceConfiguration logic_device_configuration = 2;
    }

    CaptureSettings capture_settings = 3;
}
message StartCaptureReply {
    CaptureInfo capture_info = 1;
}

message LogicDeviceConfiguration {
    repeated uint32 enabled_analog_channels = 1;
    repeated uint32 enabled_digital_channels = 2;

    uint32 digital_sample_rate = 3;
    uint32 analog_sample_rate = 4;

    double digital_threshold = 5;

    repeated GlitchFilterEntry glitch_filters = 6;
}
message GlitchFilterEntry {
    uint32 channel_index = 1;
    double pulse_width = 2;
}

message CaptureSettings {
    // Capture buffer size (in megabytes)
    uint32 buffer_size = 1;
    CaptureMode capture_mode = 2;
    // Time to stop capture after (in seconds)
    //
    // Only applies if capture_mode is `CaptureMode.STOP_AFTER_TIME`
    double stop_after_time = 3;

    // Duration to trim data down to after capture completes
    //
    // When trigger is active, we trim relative to the trigger, not the end of capture
    double trim_time = 4;

    DigitalTriggerSettings digital_trigger = 5;
}

enum CaptureMode {
    CIRCULAR = 0;
    STOP_AFTER_TIME = 1;
    STOP_ON_DIGITAL_TRIGGER = 2;
}

message DigitalTriggerSettings {
    DigitalTriggerType trigger_type = 1;

    double record_after_trigger_time = 2;

    uint32 trigger_channel_index = 3;

    double min_pulse_duration = 4;
    double max_pulse_duration = 5;

    repeated DigitalTriggerLinkedChannel linked_channels = 6;
}

enum DigitalTriggerType {
    RISING = 0;
    FALLING = 1;
    PULSE_HIGH = 2;
    PULSE_LOW = 3;
}

message DigitalTriggerLinkedChannel {
    uint32 channel_index = 1;
    DigitalTriggerLinkedChannelState state = 2;
}

enum DigitalTriggerLinkedChannelState {
    LOW = 0;
    HIGH = 1;
}


// Stop Capture
message StopCaptureRequest {
    uint64 capture_id = 1;
}
message StopCaptureReply {
}

// Stop Capture
message WaitCaptureRequest {
    uint64 capture_id = 1;
}
message WaitCaptureReply {
}

// Load Capture
message LoadCaptureRequest {
    // Filepath of Logic 2 .sal capture file to load.
    string filepath = 1;
}
message LoadCaptureReply {
    // Information about the capture that was loaded.
    CaptureInfo capture_info = 1;
}


message SaveCaptureRequest {
    // Id of capture to save.
    uint64 capture_id = 1;

    // Full filepath to save the file to, usually ending in ".sal".
    string filepath = 2;
}
message SaveCaptureReply {
}


message CloseCaptureRequest {
    // Id of capture to close.
    uint64 capture_id = 1;
}
message CloseCaptureReply {
}


message ExportRawDataCsvRequest {
    // Id of capture to export data from.
    uint64 capture_id = 1;

    // Directory to create exported CSV files in.
    string directory = 2;

    // Channels to export.
    repeated ChannelIdentifier channels = 3;

    // Must be between 1 and 1,000,000, inclusive.
    uint64 analog_downsample_ratio = 4;

    // If true, timestamps will be in ISO8601 format.
    bool iso8601 = 5;
}
message ExportRawDataCsvReply {
}


message ExportRawDataBinaryRequest {
    // Id of capture to export data from.
    uint64 capture_id = 1;

    // Directory to create exported binary files in.
    string directory = 2;

    // Channels to export.
    repeated ChannelIdentifier channels = 3;

    // Must be between 1 and 1,000,000, inclusive.
    uint64 analog_downsample_ratio = 4;
}
message ExportRawDataBinaryReply {
}


message AnalyzerSettingValue {
    oneof value {
        // String value
        string string_value = 1;

        // Integer value
        int64 int64_value = 2;

        // Boolean value
        bool bool_value = 3;

        // Double floating-point value
        double double_value = 4;
    }
}
message AddAnalyzerRequest {
    // Id of capture to add analyzer to.
    uint64 capture_id = 1;

    // Name of analyzer. This should exactly match the name seen in the application.
    // Examples: "SPI", "I2C", "Async Serial"
    string analyzer_name = 2;

    // User-facing name for the analyzer.
    string analyzer_label = 3;

    // Analyzer settings. These should match the names shown in analyzer's settings
    // shown in the application.
    map<string, AnalyzerSettingValue> settings = 4;
}
message AddAnalyzerReply {
    // Id of the newly created analyzer.
    uint64 analyzer_id = 1;
}

message RemoveAnalyzerRequest {
    // Id of capture to remove analyzer from.
    uint64 capture_id = 1;

    // Id of analyzer to remove.
    uint64 analyzer_id = 2;
}
message RemoveAnalyzerReply {
}

message ExportDataTableRequest {
    // Id of capture to export data from.
    uint64 capture_id = 1;

    // Path to export CSV data to.
    string filepath = 2;

    // Id of analyzers to export data from.
    repeated uint64 analyzer_ids = 3;

    // If true, timestamps will be in ISO8601 format.
    bool iso8601 = 5;
}
message ExportDataTableReply{
}

message ExportAnalyzerLegacyRequest {
    // Id of capture to export data from.
    uint64 capture_id = 1;

    // Path to export data to.
    string filepath = 2;

    // Id of analyzer to export data from.
    uint64 analyzer_id = 3;

    // Radix to use for exported data.
    RadixType radix_type = 4;
}
message ExportAnalyzerLegacyReply{
}