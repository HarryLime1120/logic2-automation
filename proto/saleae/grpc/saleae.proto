syntax = "proto3";

option java_multiple_files = true;
option java_package = "saleae";
option java_outer_classname = "SaleaeProto";
option objc_class_prefix = "Saleae";

package saleae.automation;


service Manager {
  rpc GetDevices (GetDevicesRequest) returns (GetDevicesReply) {}

  rpc LoadCapture (LoadCaptureRequest) returns (LoadCaptureReply) {}
  rpc SaveCapture (SaveCaptureRequest) returns (SaveCaptureReply) {}
  rpc CloseCapture (CloseCaptureRequest) returns (CloseCaptureReply) {}

  rpc AddAnalyzer (AddAnalyzerRequest) returns (AddAnalyzerReply) {}
  rpc RemoveAnalyzer (RemoveAnalyzerRequest) returns (RemoveAnalyzerReply) {}

  rpc ExportRawDataCsv (ExportRawDataCsvRequest) returns (ExportRawDataCsvReply) {}
  rpc ExportRawDataBinary (ExportRawDataBinaryRequest) returns (ExportRawDataBinaryReply) {}

  rpc ExportDataTable (ExportDataTableRequest) returns (ExportDataTableReply) {}
  rpc ExportAnalyzerLegacy (ExportAnalyzerLegacyRequest) returns (ExportAnalyzerLegacyReply) {}
}


// Core Types

enum ErrorCode {
    UNKNOWN_ERROR_CODE = 0; // Not used

    INTERNAL_EXCEPTION = 1;

    INVALID_REQUEST = 10;

    LOAD_CAPTURE_FAILED = 20;

    CAPTURE_IN_PROGRESS = 21;
    UNSUPPORTED_FILE_TYPE = 22;
}

enum RadixType {
    UNKNOWN_RADIX_TYPE = 0;
    BINARY = 1;
    DECIMAL = 2;
    HEXADECIMAL = 3;
    ASCII = 4;
};

// Enum fields don't explicitly track presence if not tagged as optional. In these cases
// 0 is the implicitly serialized value, which is indistinguishable from the 0 value in the enum.
// But 0 is required as the first value in an enum. This should be set to something like UNKNOWN instead.
// Or we should always mark them as optional? I'm not sure how the client-side handles that if the value is 
// present but 0.
enum DeviceType {
    UNKNOWN_DEVICE_TYPE = 0;
    LOGIC_8 = 1;
    LOGIC_PRO_8 = 2;
    LOGIC_PRO_16 = 3;
}

message Device {
    uint64 device_id = 1;
    DeviceType device_type = 2;
    string serial_number = 3;
}

enum ChannelType {
    DIGITAL = 0;
    ANALOG = 1;
}

message ChannelIdentifier {
    uint64 device_id = 1;
    ChannelType type = 2;
    uint64 index = 3;
}

message CaptureInfo {
    uint64 capture_id = 1;
}



// Request/Reply Types


// Get Devices
message GetDevicesRequest {
}
message GetDevicesReply {
    repeated Device devices = 1;
}




// Load Capture
message LoadCaptureRequest {
    string filepath = 1;
}
message LoadCaptureReply {
    CaptureInfo capture_info = 1;
}

// Save Capture
message SaveCaptureRequest {
    uint64 capture_id = 1;
    string filepath = 2;
}
message SaveCaptureReply {
}


// Close Capture
message CloseCaptureRequest {
    uint64 capture_id = 1;
}
message CloseCaptureReply {
}


// Export Raw Data
message ExportRawDataCsvRequest {
    uint64 capture_id = 1;

    string directory = 2;

    repeated ChannelIdentifier channels = 3;

    // Must be between 1 and 1,000,000, inclusive
    uint64 analog_downsample_ratio = 4;

    // If set to true, timestamps will be in ISO8601 format
    bool iso8601 = 5;
}
message ExportRawDataCsvReply {
}

message ExportRawDataBinaryRequest {
    uint64 capture_id = 1;

    string directory = 2;

    repeated ChannelIdentifier channels = 3;

    // Must be between 1 and 1,000,000, inclusive
    uint64 analog_downsample_ratio = 4;
}
message ExportRawDataBinaryReply {
}


message AnalyzerSettingValue {
    oneof value {
        string string_value = 1;
        int64 int64_value = 2;
        bool bool_value = 3;
        double double_value = 4;
    }
}
message AddAnalyzerRequest {
    uint64 capture_id = 1;

    string analyzer_name = 2;
    string analyzer_label = 3;
    map<string, AnalyzerSettingValue> settings = 4;
}
message AddAnalyzerReply {
    uint64 analyzer_id = 1;
}

message RemoveAnalyzerRequest {
    uint64 capture_id = 1;
    uint64 analyzer_id = 2;
}
message RemoveAnalyzerReply {
}

message ExportDataTableRequest {
    uint64 capture_id = 1;

    string filepath = 2;

    repeated uint64 analyzer_ids = 3;
}
message ExportDataTableReply{
}

message ExportAnalyzerLegacyRequest {
    uint64 capture_id = 1;

    string filepath = 2;

    uint64 analyzer_id = 3;
    RadixType radix_type = 4;
}
message ExportAnalyzerLegacyReply{
}