syntax = "proto3";

option java_multiple_files = true;
option java_package = "saleae";
option java_outer_classname = "SaleaeProto";
option objc_class_prefix = "Saleae";

package saleae.automation;


service Manager {
  rpc GetDevices (GetDevicesRequest) returns (GetDevicesReply) {}

  rpc StartCapture (StartCaptureRequest) returns (StartCaptureReply) {}
  rpc StopCapture (StopCaptureRequest) returns (StopCaptureReply) {}
  rpc WaitCapture (WaitCaptureRequest) returns (WaitCaptureReply) {}

  rpc LoadCapture (LoadCaptureRequest) returns (LoadCaptureReply) {}
  rpc SaveCapture (SaveCaptureRequest) returns (SaveCaptureReply) {}
  rpc CloseCapture (CloseCaptureRequest) returns (CloseCaptureReply) {}

  rpc ExportRawDataCsv (ExportRawDataCsvRequest) returns (ExportRawDataCsvReply) {}
  rpc ExportRawDataBinary (ExportRawDataBinaryRequest) returns (ExportRawDataBinaryReply) {}
}


// Core Types

enum ErrorCode {
    UNKNOWN = 0; // Not used

    INTERNAL_EXCEPTION = 1;

    INVALID_REQUEST = 10;

    LOAD_CAPTURE_FAILED = 20;

    CAPTURE_IN_PROGRESS = 21;
    UNSUPPORTED_FILE_TYPE = 22;

    MISSING_DEVICE = 50;
    DEVICE_ERROR = 51;
    OOM = 52;
}

// Enum fields don't explicitly track presence if not tagged as optional. In these cases
// 0 is the implicitly serialized value, which is indistinguishable from the 0 value in the enum.
// But 0 is required as the first value in an enum. This should be set to something like UNKNOWN instead.
// Or we should always mark them as optional? I'm not sure how the client-side handles that if the value is 
// present but 0.
enum DeviceType {
    UNKNOWN_DEVICE_TYPE = 0;
    LOGIC_8 = 1;
    LOGIC_PRO_8 = 2;
    LOGIC_PRO_16 = 3;
}

message Device {
    uint64 device_id = 1;
    DeviceType device_type = 2;
    string serial_number = 3;
}

enum ChannelType {
    DIGITAL = 0;
    ANALOG = 1;
}

message ChannelIdentifier {
    uint64 device_id = 1;
    ChannelType type = 2;
    uint64 index = 3;
}

message CaptureInfo {
    uint64 capture_id = 1;
}



// Request/Reply Types


// Get Devices
message GetDevicesRequest {
}
message GetDevicesReply {
    repeated Device devices = 1;
}


// Start Capture
message StartCaptureRequest {
    string device_serial_number = 1;

    oneof device_configuration {
        LogicDeviceConfiguration logic_device_configuration = 2;
    }

    CaptureSettings capture_settings = 3;
}
message StartCaptureReply {
    CaptureInfo capture_info = 1;
}

message LogicDeviceConfiguration {
    repeated uint32 enabled_analog_channels = 1;
    repeated uint32 enabled_digital_channels = 2;

    uint32 digital_sample_rate = 3;
    uint32 analog_sample_rate = 4;

    double digital_threshold = 5;

    repeated GlitchFilterEntry glitch_filters = 6;
}
message GlitchFilterEntry {
    uint32 channel_index = 1;
    double pulse_width = 2;
}

message CaptureSettings {
    // Capture buffer size (in megabytes)
    uint32 buffer_size = 1;
    CaptureMode capture_mode = 2;
    // Time to stop capture after (in seconds)
    //
    // Only applies if capture_mode is `CaptureMode.STOP_AFTER_TIME`
    double stop_after_time = 3;

    // Duration to trim data down to after capture completes
    //
    // When trigger is active, we trim relative to the trigger, not the end of capture
    double trim_time = 4;

    DigitalTriggerSettings digital_trigger = 5;
}

enum CaptureMode {
    CIRCULAR = 0;
    STOP_AFTER_TIME = 1;
    STOP_ON_DIGITAL_TRIGGER = 2;
}

message DigitalTriggerSettings {
    DigitalTriggerType trigger_type = 1;

    double record_after_trigger_time = 2;

    uint32 trigger_channel_index = 3;

    double min_pulse_duration = 4;
    double max_pulse_duration = 5;

    repeated DigitalTriggerLinkedChannel linked_channels = 6;
}

enum DigitalTriggerType {
    RISING = 0;
    FALLING = 1;
    PULSE_HIGH = 2;
    PULSE_LOW = 3;
}

message DigitalTriggerLinkedChannel {
    uint32 channel_index = 1;
    DigitalTriggerLinkedChannelState state = 2;
}

enum DigitalTriggerLinkedChannelState {
    LOW = 0;
    HIGH = 1;
}


// Stop Capture
message StopCaptureRequest {
    uint64 capture_id = 1;
}
message StopCaptureReply {
}

// Stop Capture
message WaitCaptureRequest {
    uint64 capture_id = 1;
}
message WaitCaptureReply {
}



// Load Capture
message LoadCaptureRequest {
    string filepath = 1;
}
message LoadCaptureReply {
    CaptureInfo capture_info = 1;
}

// Save Capture
message SaveCaptureRequest {
    uint64 capture_id = 1;
    string filepath = 2;
}
message SaveCaptureReply {
}


// Close Capture
message CloseCaptureRequest {
    uint64 capture_id = 1;
}
message CloseCaptureReply {
}


// Export Raw Data
message ExportRawDataCsvRequest {
    uint64 capture_id = 1;

    string directory = 2;

    repeated ChannelIdentifier channels = 3;

    // Must be between 1 and 1,000,000, inclusive
    uint64 analog_downsample_ratio = 4;

    // If set to true, timestamps will be in ISO8601 format
    bool iso8601 = 5;
}
message ExportRawDataCsvReply {
}

message ExportRawDataBinaryRequest {
    uint64 capture_id = 1;

    string directory = 2;

    repeated ChannelIdentifier channels = 3;

    // Must be between 1 and 1,000,000, inclusive
    uint64 analog_downsample_ratio = 4;
}
message ExportRawDataBinaryReply {
}